# Versioning

Those guidelines are coming from
[Cluster API](https://github.com/kubernetes-sigs/cluster-api/blob/main/VERSIONING.md)
as we try to follow closely the release process

<!-- markdownlint-disable -->
## TL;DR:
<!-- markdownlint-restore -->

- We follow [Semantic Versioning (semver)](https://semver.org/).
- We try to follow Cluster API release cadence,
- The cadence is subject to change if necessary, refer to the
  [Milestones](https://github.com/kubernetes-sigs/cluster-api/milestones) page
  for up-to-date information.
- The _main_ branch is where development happens, this might include breaking
  changes.
- The _release-X_ branches contain stable, backward compatible code. A new
  _release-X_ branch is created at every major (X) release.

## Overview

Cluster API follows [Semantic Versioning](https://semver.org).
I'd recommend reading the aforementioned link if you're not familiar,
but essentially, for any given release X.Y.Z:

- an X (*major*) release indicates a set of backwards-compatible code.
  Changing X means there's a breaking change.

- a Y (*minor*) release indicates a minimum feature set.  Changing Y means
  the addition of a backwards-compatible feature.

- a Z (*patch*) release indicates minimum set of bugfixes.  Changing
  Z means a backwards-compatible change that doesn't add functionality.

*NB*: If the major release is `0`, any minor release may contain breaking
changes.

These guarantees extend to all code exposed in public APIs of
Cluster API Provider Metal3. This includes code both in Cluster API Provider
Baremetal itself, *plus types from dependencies in public APIs*.  Types and
functions not in public APIs are not considered part of the guarantee.

In order to easily maintain the guarantees, we have a couple of processes
that we follow.

## Branches

Cluster API Provider Metal3 contains two types of branches: the *main*
branch and *release-X* branches.

The *main* branch is where development happens.  All the latest and
greatest code, including breaking changes, happen on main.

The *release-X* branches contain stable, backwards compatible code.  Every
major (X) release, a new such branch is created.  It is from these
branches that minor and patch releases are tagged.  In some cases, it may
be necessary to open PRs for bugfixes directly against stable branches, but
this should generally be avoided.

The maintainers are responsible for updating the contents of this branch;
generally, this is done just before a release using release tooling that
filters and checks for changes tagged as breaking (see below).

## PR Process

Every PR should be annotated with an icon indicating whether it's
a:

- Breaking change: :warning: (`:warning:`)
- Non-breaking feature: :sparkles: (`:sparkles:`)
- Patch fix: :bug: (`:bug:`)
- Docs: :book: (`:book:`)
- Infra/Tests/Other: :seedling: (`:seedling:`)

You can also use the equivalent emoji directly, since GitHub doesn't
render the `:xyz:` aliases in PR titles.

Individual commits should not be tagged separately, but will generally be
assumed to match the PR. For instance, if you have a bug fix in with
a breaking change, it's generally encouraged to submit the bug fix
separately, but if you must put them in one PR, mark the commit
separately.

### Commands and Workflow

Cluster API Provider Metal3 follows the standard Kubernetes workflow: any PR
needs `lgtm` and `approved` labels, PRs authors must have signed the CNCF CLA,
and PRs must pass the tests before being merged.  See [the contributor
docs](https://github.com/kubernetes/community/blob/master/contributors/guide/pull-requests.md#the-testing-and-merge-workflow)
for more info.

We use the same priority and kind labels as Kubernetes.  See the labels
tab in GitHub for the full list.

The standard Kubernetes comment commands should work in
Cluster API Provider Metal3.  See [Prow](https://prow.k8s.io/command-help)
for a command reference.

## Release Process

Minor and patch releases are generally done immediately after a feature or
bugfix is landed, or sometimes a series of features tied together.

Minor releases will only be tagged on the *most recent* major release
branch, except in exceptional circumstances.  Patches will be backported
to maintained stable versions, as needed.

Major releases are done shortly after a breaking change is merged -- once
a breaking change is merged, the next release *must* be a major revision.
We don't intend to have a lot of these, so we may put off merging breaking
PRs until a later date.

### Exact Steps

Refer to the [releasing document](./docs/releasing.md) for the exact steps.

### Breaking Changes

Try to avoid breaking changes.  They make life difficult for users, who
have to rewrite their code when they eventually upgrade, and for
maintainers/contributors, who have to deal with differences between main
and stable branches.

That being said, we'll occasionally want to make breaking changes. They'll
be merged onto main, and will then trigger a major release (see [Release
Process](#release-process)).  Because breaking changes induce a major
revision, the maintainers may delay a particular breaking change until
a later date when they are ready to make a major revision with a few
breaking changes.

If you're going to make a breaking change, please make sure to explain in
detail why it's helpful.  Is it necessary to cleanly resolve an issue?
Does it improve API ergonomics?

Maintainers should treat breaking changes with caution, and evaluate
potential non-breaking solutions (see below).

Note that API breakage in public APIs due to dependencies will trigger
a major revision, so you may occasionally need to have a major release
anyway, due to changes in libraries like `k8s.io/client-go` or
`k8s.io/apimachinery`.

<!-- markdownlint-disable -->
## Why don't we...
<!-- markdownlint-restore -->

### Use "next"-style branches

Development branches:

- don't win us much in terms of maintenance in the case of breaking
  changes (we still have to merge/manage multiple branches for development
  and stable)

- can be confusing to contributors, who often expect main to have the
  latest changes.

### Never break compatibility

Never doing a new major release could be an admirable goal, but gradually
leads to API cruft.

Since one of the goals of Cluster API is to be a friendly and
intuitive API, we want to avoid too much API cruft over time, and
occaisonal breaking changes in major releases help accomplish that goal.

Furthermore, our dependency on Kubernetes libraries makes this difficult
(see below)

### Always assume we've broken compatibility

*a.k.a. k8s.io/client-go style* While this makes life easier (a bit) for
maintainers, it's problematic for users.  While breaking changes arrive sooner,
upgrading becomes very painful.

Furthermore, we still have to maintain stable branches for bugfixes, so
the maintenance burden isn't lessened by a ton.
